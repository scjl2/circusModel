
--SAFELET

--SAFELET CHANNELS

channel done_safeletFW

channel initializeApplicationCall
channel initializeApplicationRet
channel checkSchedulable : MissionID.Bool
channel getSequencerCall
channel getSequencerRet : SchedulableID
channel end_safelet_app

nametype SafeletFWChanSet =
  {|initializeApplicationCall,initializeApplicationRet,
    getSequencerCall,getSequencerRet,
    start_toplevel_sequencer, end_safelet_app,done_safeletFW,
    checkSchedulable, deregister|}


SafeletFW =
  SafeletFWBehaviour

SafeletFWBehaviour=

  InitializeApplication ;
  Execute_S ;
  SKIP

InitializeApplication =
  initializeApplicationCall ->
  initializeApplicationRet ->
  SKIP

--Contains GetSequencerMeth events
Execute_S =
  getSequencerCall ->
  getSequencerRet?topLevelSequencer ->
  if topLevelSequencer != nullSequencerId then
  (
      start_toplevel_sequencer.topLevelSequencer ->
      Methods_S({}, topLevelSequencer) ;
      end_safelet_app ->
      SKIP
  )
  else
    end_safelet_app ->
    done_safeletFW -> SKIP

  Methods_S(globallyRegistered, sequencerID) =
  (
    Register_S(globallyRegistered, sequencerID)
    []
    Deregister_S(globallyRegistered, sequencerID)
    []
    done_toplevel_sequencer -> SKIP
  )


  Register_S(globallyRegistered, sequencerID) =
  (
      register?schedulable:diff(SchedulableID, globallyRegistered)?mission ->
      checkSchedulable.mission!True ->
      Methods_S(union(globallyRegistered,{schedulable}), sequencerID)
  )
  []
  (
    register?schedulable:globallyRegistered?mission ->
    checkSchedulable.mission!False ->
    Methods_S(globallyRegistered, sequencerID)
  )

  Deregister_S(globallyRegistered, sequencerID) =
    deregister?schedulables ->
    Methods_S(diff(globallyRegistered,schedulables), sequencerID)

assert SafeletFW; Loop :[ deadlock free [FD] ]
assert SafeletFW :[ divergence free ]
assert SafeletFW :[ deterministic  [FD] ]

--Schedulable SHARED
channel release_complete:SchedulableID
channel done_schedulable : SchedulableID
channel end_releases:SchedulableID
channel fire:SchedulableID
channel releaseCall:SchedulableID
channel releaseRet:SchedulableID

channel  signalTerminationCall : SchedulableID
channel  signalTerminationRet : SchedulableID
channel set_applicationTerminating: SchedulableID.Bool
channel get_applicationTerminating: SchedulableID.Bool

nametype ManagedSchedulableFWChanSet =
  {| done_schedulable,fire,releaseCall,releaseRet,
  signalTerminationCall,signalTerminationRet,set_applicationTerminating,get_applicationTerminating,
  cleanupSchedulableCall, cleanupSchedulableRet, activate_schedulables |}


--TopLevelMissionSequencer



--TLMS CHANNELS



channel  start_toplevel_sequencer:SchedulableID

channel  done_toplevel_sequencer


channel set_continue : SchedulableID . Bool

channel end_toplevelsequencerState : SchedulableID

nametype TopLevelMissionSequencerFWChanSet = union(
  union(MissionSequencerFWSharedChanSet, TLMSStateSync) ,
  {|done_safeletFW, start_toplevel_sequencer,end_methods,
getNextMissionCall, getNextMissionRet, start_mission, done_mission,
 done_toplevel_sequencer, end_sequencer_app |})

nametype TopLevelMissionSequencerFWChan  =  {| start_toplevel_sequencer,  end_sequencer_app, end_methods, get_continue, set_continue |}
nametype TLMSStateSync = {|get_continue, set_continue, get_currentMission, set_currentMission, end_toplevelsequencerState |}

--TLMS

TopLevelMissionSequencerFW(sequencer) =
(
    TopLevelMissionSequencerFWState(sequencer, nullMissionId, True )
      [| TLMSStateSync |]
    TopLevelMissionSequencerFWBehaviour(sequencer)
)\ TLMSStateSync


TopLevelMissionSequencerFWState(sequencer, currentMission, continue) =
  (
    set_currentMission.sequencer?newCurrentMission ->
    TopLevelMissionSequencerFWState(sequencer, newCurrentMission, continue)
  )
  []
  (
    get_currentMission.sequencer!currentMission ->
    TopLevelMissionSequencerFWState(sequencer, currentMission, continue)
  )
  []
  (
    get_continue.sequencer!continue ->
    TopLevelMissionSequencerFWState(sequencer, currentMission, continue)
  )
  []
  (
    set_continue.sequencer?newContinue ->
    TopLevelMissionSequencerFWState(sequencer, currentMission, newContinue)
  )
  []
  (
    end_toplevelsequencerState.sequencer ->
    SKIP
  )


TopLevelMissionSequencerFWBehaviour(sequencer)=
(
  done_safeletFW ->
  end_toplevelsequencerState.sequencer ->
  end_sequencer_app.sequencer ->
  SKIP
)
[]
(
  Start_TLS(sequencer) ;
  Execute_TLS(sequencer) ;
  Finish_TLS(sequencer) ;
  end_toplevelsequencerState.sequencer ->
  end_sequencer_app.sequencer ->
  SKIP
)

Start_TLS(sequencer)  =
 start_toplevel_sequencer.sequencer ->
 SKIP

Execute_TLS(sequencer)  =
(
  RunMission_TLS(sequencer)
)

RunMission_TLS(sequencer) =
 GetNextMission_TLS(sequencer) --;
-- StartMission_TLS(sequencer) ;
-- Continue_TLS(sequencer)

GetNextMission_TLS(sequencer)  =
  getNextMissionCall.sequencer ->
  getNextMissionRet.sequencer?next ->
  StartMission_TLS(sequencer, next)

StartMission_TLS(sequencer, currentMission) =
 -- get_currentMission.sequencer?currentMission ->
  (
    if currentMission != nullMissionId then
    (
      start_mission.currentMission.sequencer ->
      done_mission.currentMission?returnedcontinue ->
  --  set_continue.sequencer.returnedcontinue ->
    --  SKIP
    Continue_TLS(sequencer,returnedcontinue)
    )
     else
    (
      --set_continue.sequencer!False ->
      --SKIP
      Continue_TLS(sequencer, False)
    )
  )

Continue_TLS(sequencer, continue) =
if continue == True then
  (
 --   get_continue.sequencer?continue:({True}) ->
    RunMission_TLS(sequencer)
  )
 -- []
else
  (
 --   get_continue.sequencer?continue:( {False}) ->
    SKIP
  )

Finish_TLS(sequencer)   =
  done_toplevel_sequencer ->
  SKIP

assert TopLevelMissionSequencerFW(schedulableA); Loop :[ deadlock free [FD] ]
assert TopLevelMissionSequencerFW(schedulableA) :[ divergence free ]
assert TopLevelMissionSequencerFW(schedulableA) :[ deterministic  [FD] ]


--MissionFW

--Mission Channels

channel set_controllingSequencer : MissionID.SchedulableID
channel set_applicationTerminating_M : MissionID.Bool
channel get_applicationTerminating_M : MissionID.Bool
channel set_missionTerminating : MissionID.Bool
channel set_activeSchedulables: MissionID.Set(SchedulableID)
channel get_activeSchedulables: MissionID.Set(SchedulableID)
channel add_schedulable: MissionID.SchedulableID
channel remove_activeSchedulables : MissionID.SchedulableID
channel get_missionTerminating : MissionID.Bool
channel get_registeredSchedulables : MissionID.Set(SchedulableID)
channel end_mission_state : MissionID
channel get_controllingSequencer : MissionID.SchedulableID


nametype MissionFWStateChan =
  {|activate_schedulables, end_mission_state, set_controllingSequencer,
  set_applicationTerminating_M, get_applicationTerminating_M,
  set_missionTerminating, set_activeSchedulables,
  get_activeSchedulables, add_schedulable, remove_activeSchedulables,
  get_missionTerminating, get_registeredSchedulables, get_controllingSequencer |}

channel start_mission : MissionID.SchedulableID

channel initializeCall : MissionID
channel initializeRet : MissionID

channel register : SchedulableID.MissionID
channel deregister : Set(SchedulableID)


channel setCeilingPriority : MissionID.ObjectID.Bit
channel done_schedulables : MissionID
channel activate_schedulables : MissionID
channel stop_schedulables : MissionID
channel schedulables_stopped : MissionID


channel schedulables_terminated : MissionID
channel end_mission_terminations : MissionID
channel requestTermination : MissionID.SchedulableID
channel cleanupSchedulableCall : SchedulableID
channel cleanupSchedulableRet : SchedulableID
channel cleanupMissionCall : MissionID
channel cleanupMissionRet : MissionID.Bool
channel end_mission_app : MissionID
channel done_mission : MissionID.Bool


nametype MissionFWCHanSet = union(
  MissionFWStateChan,
  {|done_safeletFW, done_toplevel_sequencer, initializeCall, initializeRet,
checkSchedulable, throw, setCeilingPriority, done_schedulables,
activate_schedulables, stop_schedulables, done_schedulables, schedulables_stopped,
signalTerminationCall, signalTerminationRet, done_schedulable, end_mission_terminations,
requestTermination, deregister,
cleanupMissionCall, cleanupMissionRet, cleanupSchedulableCall, cleanupSchedulableRet,
end_mission_app, done_mission, start_mission |})


nametype TerminateSync =
  {| schedulables_terminated, schedulables_stopped |}


MissionFW(mission) =
(
  MissionFWState(mission, {}, {}, False, False, nullSequencerId)
    [|MissionFWStateChan|]
  MissionFWBehaviour(mission)
) \ diff(MissionFWStateChan, {|activate_schedulables|})


MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, applicationTerminating, controllingSequencer) =
  (
    set_controllingSequencer.mission?mySequencer ->
    MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, applicationTerminating, mySequencer)
  )
  []
  (
    get_controllingSequencer.mission!controllingSequencer ->
    MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, applicationTerminating, controllingSequencer)
  )
  []
  (
    set_applicationTerminating_M.mission?newApplicationTerminating ->
    MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, newApplicationTerminating, controllingSequencer)
  )
  []
  (
    get_applicationTerminating_M.mission!applicationTerminating ->
    MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, applicationTerminating, controllingSequencer)
  )
  []
  (
    set_missionTerminating.mission?newMissionTerminating ->
    MissionFWState(mission, registeredSchedulables, activeSchedulables, newMissionTerminating, applicationTerminating, controllingSequencer)
  )
  []
  (
    activate_schedulables.mission ->
    MissionFWState(mission, registeredSchedulables, registeredSchedulables, missionTerminating, applicationTerminating, controllingSequencer)
  )
  []
  (
    get_activeSchedulables.mission!activeSchedulables ->
    MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, applicationTerminating, controllingSequencer)
  )
  []
  (
    add_schedulable.mission?newSchedulable ->
    MissionFWState(mission, union(registeredSchedulables, {newSchedulable}), activeSchedulables, missionTerminating, applicationTerminating, controllingSequencer)
  )
  []
  (
    get_registeredSchedulables.mission!registeredSchedulables ->
    MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, applicationTerminating, controllingSequencer)
  )
  []
  (
    remove_activeSchedulables.mission?schedulable ->
    MissionFWState(mission, registeredSchedulables, diff(activeSchedulables, {schedulable}), missionTerminating, applicationTerminating, controllingSequencer)
  )
  []
  (
    get_missionTerminating.mission!missionTerminating ->
    MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, applicationTerminating, controllingSequencer)
  )
  []
  (
    end_mission_state.mission -> SKIP
  )

MissionFWBehaviour(mission) =

(
  Start_M(mission) ;
    (
      get_applicationTerminating_M.mission?applicationTerminating ->
      if applicationTerminating == False then
      (
          InitializePhase(mission) ;
          MissionPhase(mission) ;
       --   CleanupPhase(mission) ;
          MissionFWBehaviour(mission)
      )
      else
        end_mission_state.mission ->
        end_mission_app.mission ->
        SKIP
      )
)

Start_M(mission) =
  (
    start_mission.mission?mySequencer ->
    set_controllingSequencer.mission!mySequencer ->
    SKIP
  )
  []
  (
  done_safeletFW ->
  set_applicationTerminating_M.mission!True ->
  SKIP
)

  []
  (
    done_toplevel_sequencer ->
    set_applicationTerminating_M.mission!True ->
    SKIP
  )

InitializePhase(mission) =
  initializeCall.mission ->
  (
    Initialize(mission)
  )

Initialize(mission) =
(
  Register_M(mission) ;
  Initialize(mission)
)
[]
(
  SetCeilingPriority(mission) ;
  Initialize(mission)
)
[]
(
  initializeRet.mission ->
  SKIP
)

Register_M(mission) =
register?s!mission ->
(
  (
    checkSchedulable.mission?check:({True}) ->
    add_schedulable.mission!s ->
    SKIP
  )
  []
  (
    checkSchedulable.mission?check:({False}) ->
    throw.illegalStateException ->
    --CHAOS(Events)
    STOP
  )
)

RegisterException(mission) =
  register?s!mission ->
  throw.illegalStateException ->
  --CHAOS(Events)
  STOP

SetCeilingPriority(mission) =
 setCeilingPriority.mission?o?p ->
 SKIP

SetCeilingPriorityException(mission) =
 setCeilingPriority.mission?o?p ->
 throw.illegalStateException ->
 --CHAOS(Events)
 STOP

MissionPhase(mission) =
(
  Execute_M(mission)
    [|  {|done_schedulables|} |]
  MissionExceptions(mission)
)\{|done_schedulables|}

Execute_M(mission) =
 (
  get_registeredSchedulables.mission?registeredSchedulables ->
  if registeredSchedulables == {} then
  (
    done_schedulables.mission ->
    SKIP
  )
  else
  (
     activate_schedulables.mission ->
    -- set_activeSchedulables.mission!registeredSchedulables ->
     (
        TerminateAndDone(mission, registeredSchedulables)
          [| {| stop_schedulables, done_schedulables |} |]
        Methods_M(mission, registeredSchedulables)
      );
     CleanupPhase(mission, registeredSchedulables)

  )
)

TerminateAndDone(mission, activeSchedulables) =
 (
    (
    SignalTermination_M(mission)
      [| TerminateSync |]
    DoneSchedulables(mission, activeSchedulables)
  );
  done_schedulables.mission ->
  SKIP
)\TerminateSync

SignalTermination_M(mission) =
 (
  stop_schedulables.mission ->
  get_activeSchedulables.mission?schedulablesToStop ->
  StopSchedulables(schedulablesToStop) ;
  schedulables_stopped.mission ->
  SKIP
)
--/\ (schedulables_terminated.mission -> SKIP)
/\ (schedulables_stopped.mission -> SKIP )

StopSchedulables(schedulablesToStop) =
    (|||  s :  schedulablesToStop @
          signalTerminationCall.s ->
          signalTerminationRet.s ->
          SKIP)

DoneSchedulables(mission, activeSchedulables) =
--get_activeSchedulables.mission?activeSchedulables ->
(

 -- []
  (
    (
      (
        [] schedulable : activeSchedulables @
        done_schedulable.schedulable ->
        remove_activeSchedulables.mission!schedulable ->
        SKIP
      )
      ;
       (
          get_activeSchedulables.mission?activeSchedulables ->
          (
            if activeSchedulables == {} then
            (
              schedulables_stopped.mission ->
              SKIP
            )
            else
            (
              DoneSchedulables(mission, activeSchedulables)
            )
          )
        )
            --get_activeSchedulables.mission?activeSchedulables ->
     -- if activeSchedulables == {} then
   --   (
   --     schedulables_terminated.mission ->
  --     SKIP
  --    )
   --   else
   --     DoneSchedulables(mission)
    )
  )
)

Methods_M(mission, registeredSchedulables) =
(
  RequestTerminationMeth(mission, registeredSchedulables)
    [| {|end_mission_terminations|} |]
  (
    done_schedulables.mission ->
    end_mission_terminations.mission ->
    SKIP
  )
) \{| end_mission_terminations |}

RequestTerminationMeth(mission, registeredSchedulables) =
--get_registeredSchedulables.mission?registeredSchedulables ->
get_controllingSequencer.mission?controllingSequencer ->
(
  (
    end_mission_terminations.mission ->
    SKIP
  )
  []
  (
    (--
      [] schedulable: union(registeredSchedulables, {|controllingSequencer|})  @
      requestTermination.mission.schedulable ->
      SKIP
    ) ;--
    (
      (
        get_missionTerminating.mission?missionTerminating:({False}) ->
        set_missionTerminating.mission!True ->
        stop_schedulables.mission ->
        RequestTerminationMeth(mission, registeredSchedulables)
      )
      []
      (
        get_missionTerminating.mission?missionTerminating:({True}) ->
        RequestTerminationMeth(mission, registeredSchedulables)
      )
    )
  )
)

MissionExceptions(mission) =
(
  RegisterException(mission)
  |||
  SetCeilingPriorityException(mission)
)
[]
(
 done_schedulables.mission ->
  SKIP
)


CleanupPhase(mission, registeredSchedulables) =
(
  Cleanup_M(mission, registeredSchedulables)
    [|  {|cleanupMissionRet|} |]
  CleanupExceptions(mission)
)--\{|cleanupMissionRet|}

Cleanup_M(mission, registeredSchedulables) =
(
  (
    if registeredSchedulables == {} then
    (
     --get_registeredSchedulables.mission?registeredSchedulables:({}) ->
      SKIP
    )
    else
    (
     -- get_registeredSchedulables.mission?registeredSchedulables:(Set(SchedulableID)) ->
      deregister!registeredSchedulables ->
      CleanupSchedulables(mission, registeredSchedulables) ;
      SKIP
    )
  );
    cleanupMissionCall.mission ->
    cleanupMissionRet.mission?continueSequencer ->
    Finish_M(mission, continueSequencer)
)

CleanupSchedulables(mission, registeredSchedulables) =
  ||| s : registeredSchedulables @
                cleanupSchedulableCall.s ->
                cleanupSchedulableRet.s ->
                SKIP

CleanupExceptions(mission) =
(
  RegisterException(mission)
  |||
  SetCeilingPriorityException(mission)
)
[]
(
  cleanupMissionRet.mission?c ->
  SKIP
)

Finish_M(mission, continueSequencer) =
   end_mission_app.mission ->
   done_mission.mission!continueSequencer ->
   SKIP


assert MissionFW(missionA); Loop :[ deadlock free [FD] ]
assert MissionFW(missionA) :[ divergence free ]
assert MissionFW(missionA) :[ deterministic  [FD] ]


--MIssionSequencerShared
channel get_currentMission :SchedulableID.MissionID
channel set_currentMission : SchedulableID.MissionID
channel get_continue : SchedulableID.Bool

channel get_controllingMission : SchedulableID.MissionID
channel set_controllingMission : SchedulableID.MissionID

channel  getNextMissionCall : SchedulableID
channel  getNextMissionRet : (SchedulableID , MissionID)
channel  requestSequenceTermination : (SchedulableID , Bool)



channel  end_sequencer_app:SchedulableID
channel  end_methods : SchedulableID
channel  end_terminations : SchedulableID

nametype MissionSequencerFWSharedChanSet =
  {| get_currentMission, set_currentMission, get_continue, get_controllingMission,set_controllingMission,
      getNextMissionCall, getNextMissionRet, requestSequenceTermination,
       end_sequencer_app, end_methods, end_terminations |}

--SchedulablelMissionSequencer

--SMS CHANNELS

channel set_continueAbove : SchedulableID.Bool
channel set_continueBelow : SchedulableID.Bool

channel end_schedulableMissionSequencerState : SchedulableID


nametype SchedulableMissionSequencerFWChanSet = union(
  union(ManagedSchedulableFWChanSet , MissionSequencerFWSharedChanSet),
  {| done_safeletFW, set_continueAbove, set_continueBelow, end_schedulableMissionSequencerState,
done_toplevel_sequencer, start_mission, initializeRet, done_mission, requestTermination |}  )

  nametype  SchedulableMissionSequencerFWChan  = {| end_sequencer_app, end_methods, end_terminations, get_continue  |}
  nametype  SMSStateSync = {|get_currentMission, set_currentMission, get_continue, set_continueAbove, set_continueBelow,get_controllingMission, set_controllingMission, get_applicationTerminating, set_applicationTerminating, end_schedulableMissionSequencerState |}

-- SchedulableMissionSequencer

SchedulableMissionSequencerFW(sequencer)  =
(
  SchedulableMissionSequencerState(sequencer, nullMissionId, True, True, nullMissionId, False)
    [| SMSStateSync |]
  SchedulableMissionSequencerBehaviour(sequencer)
)\SMSStateSync


SchedulableMissionSequencerState(sequencer, currentMission, continueAbove, continueBelow, controllingMission, applicationTerminating) =
  (
    get_currentMission.sequencer!currentMission ->
    SchedulableMissionSequencerState(sequencer, currentMission, continueAbove, continueBelow, controllingMission, applicationTerminating)
  )
  []
  (
    set_currentMission.sequencer?newCurrentMission ->
    SchedulableMissionSequencerState(sequencer, newCurrentMission, continueAbove, continueBelow, controllingMission, applicationTerminating)
  )
    []
  (
    get_continue.sequencer!(continueAbove and continueBelow) ->
    SchedulableMissionSequencerState(sequencer, currentMission, continueAbove, continueBelow, controllingMission, applicationTerminating)
  )
  []
  (
    set_continueAbove.sequencer?newContinueAbove ->
    SchedulableMissionSequencerState(sequencer, currentMission, newContinueAbove, continueBelow, controllingMission, applicationTerminating)
  )
  []
  (
    set_continueBelow.sequencer?newContinueBelow ->
    SchedulableMissionSequencerState(sequencer, currentMission, continueAbove, newContinueBelow, controllingMission, applicationTerminating)
  )
  []
  (
    get_controllingMission.sequencer!controllingMission ->
    SchedulableMissionSequencerState(sequencer, currentMission, continueAbove, continueBelow, controllingMission, applicationTerminating)
  )
  []
  (
    set_controllingMission.sequencer?newControllingMission ->
    SchedulableMissionSequencerState(sequencer, currentMission, continueAbove, continueBelow, newControllingMission, applicationTerminating)
  )
  []
  (
    get_applicationTerminating.sequencer!applicationTerminating ->
    SchedulableMissionSequencerState(sequencer, currentMission, continueAbove, continueBelow, controllingMission, applicationTerminating)
  )
  []
  (
    set_applicationTerminating.sequencer?newApplicationTerminating ->
    SchedulableMissionSequencerState(sequencer, currentMission, continueAbove, continueBelow, controllingMission, newApplicationTerminating)
  )
  []
  (
    end_schedulableMissionSequencerState.sequencer ->
    SKIP
  )


SchedulableMissionSequencerBehaviour(sequencer) =

(
  Start_SMS(sequencer) ;
  get_applicationTerminating.sequencer?applicationTerminating ->
    (if applicationTerminating == False then
       (
          Execute_SMS(sequencer) ;
          Cleanup_SMS(sequencer) ;
          SchedulableMissionSequencerBehaviour(sequencer)
        )
     else
       end_schedulableMissionSequencerState.sequencer ->
       end_sequencer_app.sequencer ->
       SKIP
     )
)

Start_SMS(sequencer) =
 (
      Register_SMS(sequencer) --;
      --Activate_SMS(sequencer)
    )
 []
 (
  done_safeletFW ->
  set_applicationTerminating.sequencer!True ->
  SKIP
)
[]
 (
    done_toplevel_sequencer ->
    set_applicationTerminating.sequencer!True ->
    SKIP
  )
 []
 (
    activate_schedulables?someMissionID ->
    Start_SMS(sequencer)
  )

Register_SMS(sequencer) =
 register.sequencer?controllingMission ->
 Activate_SMS(sequencer, controllingMission)

Activate_SMS(sequencer, controllingMission) =
 --get_controllingMission.sequencer?controllingMission ->
 activate_schedulables.controllingMission ->
 SKIP

Execute_SMS(sequencer) =
(
   RunMission_SMS(sequencer)
)


RunMission_SMS(sequencer) =
 GetNextMission_SMS(sequencer) ;
-- StartMission_SMS(sequencer) ;
 Continue_SMS(sequencer)

GetNextMission_SMS(sequencer)  =
    getNextMissionCall.sequencer ->
    getNextMissionRet.sequencer?next ->
    StartMission_SMS(sequencer, next)
  --SKIP

StartMission_SMS(sequencer, currentMission)  =
--get_currentMission.sequencer?currentMission ->
   if  currentMission != nullMissionId  then
   (
      start_mission.currentMission.sequencer ->
      initializeRet.currentMission ->
      (
        SignalTermination_SMS(sequencer, currentMission)
         [| {| end_terminations |} |]
        (
            done_mission.currentMission?continueReturn ->
            end_terminations.sequencer ->
            set_continueBelow.sequencer!continueReturn ->
            SKIP
        )
      )--\{| end_terminations |}
  )
  else
  (
      set_continueBelow.sequencer!False ->
      SKIP
  )

Continue_SMS(sequencer) =
  (
    get_continue.sequencer?continue:({True}) ->
    RunMission_SMS(sequencer)
  )
  []
  (
    get_continue.sequencer?continue:({False}) ->
    done_schedulable.sequencer ->
    SKIP
  )

SignalTermination_SMS(sequencer, currentMission)  =
(
    (
      end_terminations.sequencer ->
      SKIP
    )
    []
    (
      signalTerminationCall.sequencer ->
      set_continueAbove.sequencer!False ->
      requestTermination.currentMission.sequencer ->
      signalTerminationRet.sequencer ->
      --
      end_terminations.sequencer ->
      SKIP
    )
 )

Cleanup_SMS(sequencer)  =
  cleanupSchedulableCall.sequencer ->
  cleanupSchedulableRet.sequencer ->
  SKIP
 -- Finish_SMS(sequencer)

--Finish_SMS(sequencer) =
--  done_schedulable.sequencer ->
--  SKIP


--assert SchedulableMissionSequencerFW(schedulableA); Loop :[ deadlock free [FD] ]
--assert SchedulableMissionSequencerFW(schedulableA) :[ divergence free ]
--assert SchedulableMissionSequencerFW(schedulableA) :[ deterministic  [FD] ]

--Aperiocidc EVENT HANDLER FW

--APEH TYPES

datatype AperiodicType = aperiodic | aperiodicLong

-- APEH Channels


channel set_pending : SchedulableID . Bool
channel get_pending : SchedulableID . Bool
channel set_data : SchedulableID . num
channel get_data : SchedulableID . num
channel end_aperiodicEventHandlerState : SchedulableID
channel end_aperiodicEventHandler_app : SchedulableID

channel fireLong : SchedulableID . num
channel releaseLongCall : SchedulableID . num
channel releaseLongRet : SchedulableID


channel scheduleNextRelease : SchedulableID.num

nametype APEHFWChanSet = union(
  union(ManagedSchedulableFWChanSet, APEHStateSync),
   {|done_safeletFW, fireLong,releaseLongCall,releaseLongRet, end_releases, circwait, release_complete,
  done_schedulable, done_toplevel_sequencer |}  )

nametype DeadlineSync_APEH =  {|releaseCall, end_releases, deschedule_handler, release_complete|}
nametype APEHStateSync =
  {|get_controllingMission, set_controllingMission, get_applicationTerminating, set_applicationTerminating,
      get_pending, set_pending, get_data, set_data, end_aperiodicEventHandlerState|}


AperiodicEventHandlerFW(schedulable, aperiodicType, deadline, deadlineMissHandler) =

(
  AperiodicEventHandlerState(schedulable, nullMissionId, False, False, 0, deadline, deadlineMissHandler )
    [|APEHStateSync|]
  AperiodicEventHandlerBehaviour(schedulable,aperiodicType, deadline, deadlineMissHandler)
)\APEHStateSync

AperiodicEventHandlerState(schedulable, controllingMission, applicationTerminating, pending, data, deadline, deadlineMissHandler) =
(
  get_controllingMission.schedulable!controllingMission ->
  AperiodicEventHandlerState(schedulable, controllingMission, applicationTerminating, pending, data, deadline, deadlineMissHandler)
)
[]
(
  set_controllingMission.schedulable?newControllingMission ->
  AperiodicEventHandlerState(schedulable, newControllingMission, applicationTerminating, pending, data, deadline, deadlineMissHandler)
)
[]
(
  get_applicationTerminating.schedulable!applicationTerminating ->
  AperiodicEventHandlerState(schedulable, controllingMission, applicationTerminating, pending, data, deadline, deadlineMissHandler)
)
[]
(
  set_applicationTerminating.schedulable?newApplicationTerminating ->
  AperiodicEventHandlerState(schedulable, controllingMission, newApplicationTerminating, pending, data, deadline, deadlineMissHandler)
)

[]
(
  set_pending.schedulable?newPending ->
  AperiodicEventHandlerState(schedulable, controllingMission, applicationTerminating, newPending, data, deadline, deadlineMissHandler)
 )
[]
(
  get_pending.schedulable!pending ->
  AperiodicEventHandlerState(schedulable, controllingMission, applicationTerminating, pending, data, deadline, deadlineMissHandler)

)
[]
(
  get_data.schedulable!data ->
  AperiodicEventHandlerState(schedulable, controllingMission, applicationTerminating, pending, data, deadline, deadlineMissHandler)

)
[]
(
  set_data.schedulable?newData ->
  AperiodicEventHandlerState(schedulable, controllingMission, applicationTerminating, pending, newData, deadline, deadlineMissHandler)

)
[]
(
  end_aperiodicEventHandlerState.schedulable ->
  SKIP
)


AperiodicEventHandlerBehaviour(schedulable,aperiodicType, deadline, deadlineMissHandler) =

(
  Start_APEH(schedulable) ;
  get_applicationTerminating.schedulable?applicationTerminating ->
  (
    if applicationTerminating == False then
    (
      Execute_APEH(schedulable,aperiodicType, deadline, deadlineMissHandler) ;
      Cleanup_APEH(schedulable)  ;
      AperiodicEventHandlerBehaviour(schedulable,aperiodicType, deadline, deadlineMissHandler)
    )
    else
      end_aperiodicEventHandlerState.schedulable ->
      end_aperiodicEventHandler_app.schedulable ->
      SKIP
    )
)


Start_APEH(schedulable) =
  (
    Register_APEH(schedulable) --;
   -- Activate_APEH(schedulable)
  )
  []
  (
  done_safeletFW ->
  set_applicationTerminating.schedulable!True ->
  SKIP
)
[]
  (
    activate_schedulables?someMissionID ->
    Start_APEH(schedulable)
  )
  []
  (
  done_toplevel_sequencer ->
  set_applicationTerminating.schedulable!True ->
  SKIP
  )


Register_APEH(schedulable) =
    register.schedulable?controllingMission ->
    Activate_APEH(schedulable, controllingMission)


Activate_APEH(schedulable, controllingMission)  =
 -- get_controllingMission.schedulable?controllingMission ->
    activate_schedulables.controllingMission ->
    SKIP


Execute_APEH(schedulable,aperiodicType, deadline, deadlineMissHandler) =
if deadlineMissHandler != nullSchedulableId then
(
  (
    (
      if aperiodicType == aperiodic then
        Ready_APEH(schedulable)
      else
        ReadyLong(schedulable)
    )
      [| DeadlineSync_APEH |]
    DeadlineClock_APEH(schedulable, deadline, deadlineMissHandler)
  )
    [|{| end_releases |}|]
  SignalTermination_APEH(schedulable)
)
else
(
  (
    if aperiodicType == aperiodic then
      Ready_APEH(schedulable)
    else
      ReadyLong(schedulable)
  )
    [|{| end_releases |}|]
  SignalTermination_APEH(schedulable)
)\{| end_releases |}

DeadlineClock_APEH(schedulable, deadline, deadlineMissHandler) =
(
 releaseCall.schedulable ->
  (
    (
      (
        circwait.deadline ->
        fire.deadlineMissHandler ->
        DeadlineClock_APEH(schedulable, deadline, deadlineMissHandler)
      )
      []
      (
        release_complete.schedulable ->
        DeadlineClock_APEH(schedulable, deadline, deadlineMissHandler)
      )
    )
  )
)
    /\
    (
        end_releases.schedulable ->
        release_complete.schedulable ->
        SKIP
    )

Ready_APEH(schedulable) =
(
  fire.schedulable ->
  releaseCall.schedulable ->
  Release_APEH(schedulable, False)
)
[]
(
  end_releases.schedulable ->
  SKIP
)

ReadyLong(schedulable) =
 (
  fireLong.schedulable?data ->
  --set_data.schedulable!data ->
  releaseLongCall.schedulable.data ->
  ReleaseLong(schedulable, data, False)
 )
 []
 (
  end_releases.schedulable ->
  SKIP
 )


SignalTermination_APEH(schedulable) =
  (
    signalTerminationCall.schedulable ->
    end_releases.schedulable ->
    signalTerminationRet.schedulable ->
    done_schedulable.schedulable ->
    SKIP
  )

Release_APEH(schedulable, pending) =

  (
    fire.schedulable ->
    --set_pending.schedulable!True ->
    Release_APEH(schedulable, True)
  )
  []
  (
    releaseRet.schedulable ->
    --get_pending.schedulable?pending ->
    if pending == True then
    (
     -- set_pending.schedulable!False ->
      release_complete.schedulable ->
      releaseCall.schedulable ->
      Release_APEH(schedulable, False)
    )
    else
       Ready_APEH(schedulable)
  )
  []
  (
    end_releases.schedulable ->
    SKIP
  )

ReleaseLong(schedulable, data, pending ) =
 (
    fireLong.schedulable?data ->
   -- set_data.schedulable!data ->
   -- set_pending.schedulable!True ->
    ReleaseLong(schedulable, data, True)
  )
  []
  (
    releaseLongRet.schedulable ->
   -- get_pending.schedulable?pending ->
    if pending == True then
    (
     -- set_pending.schedulable!False ->
      release_complete.schedulable ->
     -- get_data.schedulable?data ->
      releaseLongCall.schedulable.data ->
      ReleaseLong(schedulable, data, False)
    )
    else
       ReadyLong(schedulable)

  )
   []
  (
    end_releases.schedulable ->
    SKIP
  )

Cleanup_APEH(schedulable) =
 cleanupSchedulableCall.schedulable ->
 cleanupSchedulableRet.schedulable ->
 SKIP


assert AperiodicEventHandlerFW(schedulableA, aperiodic, 2, nullSchedulableId) ; Loop :[ deadlock free [FD] ]
assert  AperiodicEventHandlerFW(schedulableA, aperiodic, 2, nullSchedulableId) :[ divergence free ]
assert  AperiodicEventHandlerFW(schedulableA, aperiodic, 2, nullSchedulableId) :[ deterministic  [FD] ]


--OSEH and PEH SHARED
channel get_startTime : SchedulableID.num
channel set_startTime : SchedulableID.num


--One SHot EVENT HANDLER FW



-- OSEH Channels

channel end_oneshotEventHandlerState : SchedulableID
channel end_oneshotEventHandler_app : SchedulableID

channel reschedule_handler : SchedulableID.num
channel deschedule_handler : SchedulableID
channel getNextReleaseTimeCall : SchedulableID
channel getNextReleaseTimeRet : SchedulableID.num
channel descheduleCall : SchedulableID
channel descheduleRet : SchedulableID.Bool


nametype MethodsSync_OSEH =  {|end_releases, reschedule_handler, deschedule_handler|}
nametype ReleaseSync_OSEH = {|releaseCall, reschedule_handler, end_releases|}
nametype DeadlineSync_OSEH =  {|releaseCall, end_releases, deschedule_handler, release_complete|}
nametype OSEHStateSync =
  {|get_controllingMission, set_controllingMission, get_applicationTerminating, set_applicationTerminating,
  get_startTime, set_startTime,
  end_oneshotEventHandlerState|}

nametype OSEHFWChanSet = union(
  union(OSEHStateSync,ManagedSchedulableFWChanSet),
  {|reschedule_handler,deschedule_handler,getNextReleaseTimeCall,getNextReleaseTimeRet,
descheduleCall,descheduleRet, release_complete, end_releases, done_safeletFW,
circwait, getNextReleaseTimeCall, getNextReleaseTimeRet, scheduleNextRelease, done_toplevel_sequencer |} )

-- ONE SHOT EVENT HANDLER

OneShotEventHandlerFW(schedulable, startTime, deadline, deadlineMissHandler) =
(
  OneShotEventHandlerBehaviour(schedulable, deadline, deadlineMissHandler)
    [|OSEHStateSync |]
  OneShotEventHandlerState(schedulable, nullMissionId, False, startTime, deadline, deadlineMissHandler)
)\OSEHStateSync

OneShotEventHandlerState(schedulable, controllingMission, applicationTerminating, startTime, deadline, deadlineMissHandler) =
(
  get_controllingMission.schedulable!controllingMission ->
  OneShotEventHandlerState(schedulable, controllingMission, applicationTerminating, startTime, deadline, deadlineMissHandler)
)
[]
(
  set_controllingMission.schedulable?newControllingMission ->
  OneShotEventHandlerState(schedulable, newControllingMission, applicationTerminating, startTime, deadline, deadlineMissHandler)
)
[]
(
  get_applicationTerminating.schedulable!applicationTerminating ->
  OneShotEventHandlerState(schedulable, controllingMission, applicationTerminating, startTime, deadline, deadlineMissHandler)
)
[]
(
  set_applicationTerminating.schedulable?newApplicationTerminating ->
  OneShotEventHandlerState(schedulable, controllingMission, newApplicationTerminating, startTime, deadline, deadlineMissHandler)
)
[]
(
  get_startTime.schedulable!startTime ->
  OneShotEventHandlerState(schedulable, controllingMission, applicationTerminating, startTime, deadline, deadlineMissHandler)
 )
[]
(
  set_startTime.schedulable?newStartTime ->
   OneShotEventHandlerState(schedulable, controllingMission, applicationTerminating, newStartTime, deadline, deadlineMissHandler)
)
[]
(
  end_oneshotEventHandlerState.schedulable ->
  SKIP
)

OneShotEventHandlerBehaviour(schedulable, deadline, deadlineMissHandler) =

(
  Start_OSEH(schedulable) ;
  get_applicationTerminating.schedulable?applicationTerminating ->
  (
    if applicationTerminating == False then
    (
      Execute_OSEH(schedulable, deadline, deadlineMissHandler) ;
      Cleanup_OSEH(schedulable) ;
      OneShotEventHandlerBehaviour(schedulable, deadline, deadlineMissHandler)
    )
    else
      end_oneshotEventHandlerState.schedulable ->
      end_oneshotEventHandler_app.schedulable ->
      SKIP
  )
)

Start_OSEH(schedulable) =
  (
    Register_OSEH(schedulable)-- ;
   -- Activate_OSEH(schedulable)
  )
  []
  (
  done_safeletFW ->
 set_applicationTerminating.schedulable!True   ->
  SKIP
)
[]
  (
    activate_schedulables?someMissionID ->
    Start_OSEH(schedulable)
  )
  []
 (
  done_toplevel_sequencer ->
  set_applicationTerminating.schedulable!True   ->
  SKIP
  )


Register_OSEH(schedulable) =
    register.schedulable?controllingMission ->
    Activate_OSEH(schedulable, controllingMission)

Activate_OSEH(schedulable, controllingMission)  =
  --get_controllingMission.schedulable?controllingMission ->
    activate_schedulables.controllingMission ->
    SKIP

Execute_OSEH(schedulable, deadline, deadlineMissHandler) =
(
  (
    Run_OSEH(schedulable, deadline, deadlineMissHandler)
       [| MethodsSync_OSEH |]
    Methods_OSEH(schedulable)
  )
    [| {| end_releases |} |]
  SignalTermination_OSEH(schedulable)
)\{| end_releases |}

Run_OSEH(schedulable, deadline, deadlineMissHandler) =

  if deadlineMissHandler == nullSchedulableId then
  (
    ScheduleOrWait(schedulable)
      [| ReleaseSync_OSEH |]
    Release_OSEH(schedulable)
  )
  else
  (
    (
      ScheduleOrWait(schedulable)
        [| ReleaseSync_OSEH |]
      Release_OSEH(schedulable)
    )
      [| DeadlineSync_OSEH |]
      DeadlineClock_OSEH(schedulable, deadline, deadlineMissHandler)
  )

ScheduleOrWait(schedulable) =
 get_startTime.schedulable?startTime ->
 if startTime != 0 then
        Scheduled(schedulable)
  else
      NotScheduled(schedulable)

Release_OSEH(schedulable) =
 (
      releaseCall.schedulable ->
      releaseRet.schedulable ->
      release_complete.schedulable ->
      Release_OSEH(schedulable)
  )
 []
 (
    reschedule_handler.schedulable?newStartTime ->
    set_startTime.schedulable!newStartTime ->
    Release_OSEH(schedulable)
    )
 []
 (
    end_releases.schedulable ->
    SKIP
  )



DeadlineClock_OSEH(schedulable, deadline, deadlineMissHandler) =
(
 releaseCall.schedulable ->
  (
    (
      (
        circwait.deadline ->
        fire.deadlineMissHandler ->
        DeadlineClock_OSEH(schedulable, deadline, deadlineMissHandler)
      )
      []
      (
        release_complete.schedulable ->
        DeadlineClock_OSEH(schedulable, deadline, deadlineMissHandler)
      )
      []
      (
        deschedule_handler.schedulable ->
        DeadlineClock_OSEH(schedulable, deadline, deadlineMissHandler)
      )
    )
  )
)
 []
    (
        end_releases.schedulable ->
        release_complete.schedulable ->
        SKIP
    )



Scheduled(schedulable) =
 get_startTime.schedulable?startTime ->
 (
  (
    circwait.startTime ->
    releaseCall.schedulable ->
    NotScheduled(schedulable)
     )
     []
  (
      (
          deschedule_handler.schedulable ->
          NotScheduled(schedulable)
        )
      []
      (
        reschedule_handler.schedulable?newStartTime ->
        set_startTime.schedulable!newStartTime ->
        Scheduled(schedulable)
      )
   )
 )


NotScheduled(schedulable) =
    (
          deschedule_handler.schedulable ->
          NotScheduled(schedulable)
       )
    []
    (
          reschedule_handler.schedulable?newStartTime ->
          set_startTime.schedulable!newStartTime ->
          Scheduled(schedulable)
        )
    []
    (
    end_releases.schedulable ->
    SKIP
  )


Methods_OSEH(schedulable) =
 (
   Deschedule(schedulable) ;
   Methods_OSEH(schedulable)
 )
 []
 (
   GetNextReleaseTime(schedulable) ;
   Methods_OSEH(schedulable)
 )
 []
 (
    ScheduleNextRelease(schedulable);
   Methods_OSEH(schedulable)
 )
 []
 (
   end_releases.schedulable ->
   SKIP
  )


Deschedule(schedulable) =

  descheduleCall.schedulable ->
  deschedule_handler.schedulable ->
  get_startTime.schedulable?startTime ->
 (
  if startTime == 0 then
  --set_wasScheduled.schedulable!False ->
  set_startTime.schedulable.0 ->
    descheduleRet.schedulable.False ->
  SKIP

 else
  --set_wasScheduled.schedulable!True->
  set_startTime.schedulable.0 ->
    descheduleRet.schedulable.True ->
  SKIP

 )

GetNextReleaseTime(schedulable) =
  getNextReleaseTimeCall.schedulable ->
  get_startTime.schedulable?startTime ->
  getNextReleaseTimeRet.schedulable!startTime ->
  SKIP

ScheduleNextRelease(schedulable) =
 scheduleNextRelease.schedulable?newStartTime ->
 set_startTime.schedulable!newStartTime ->
 if newStartTime == 0 then
  (
    deschedule_handler.schedulable ->
    SKIP
  )
 else
  (
    reschedule_handler.schedulable!newStartTime ->
    SKIP
  )

SignalTermination_OSEH(schedulable) =
 signalTerminationCall.schedulable ->
 end_releases.schedulable ->
 signalTerminationRet.schedulable ->
 done_schedulable.schedulable ->
 SKIP

Cleanup_OSEH(schedulable) =
  cleanupSchedulableCall.schedulable ->
  cleanupSchedulableRet.schedulable ->
  SKIP


assert OneShotEventHandlerFW(schedulableA, 0, 2, nullSchedulableId); Loop :[ deadlock free [FD] ]
assert OneShotEventHandlerFW(schedulableA, 0, 2, nullSchedulableId) :[ divergence free ]
assert OneShotEventHandlerFW(schedulableA, 0, 2, nullSchedulableId) :[ deterministic  [FD] ]


--PERIODIC EVENT HANDLER FW


--datatype boolean = True | False

-- PEH Channels


channel get_missedReleases : SchedulableID.num
channel set_missedReleases : SchedulableID.num
channel get_periodicTerminating : SchedulableID.Bool
channel set_periodicTerminating : SchedulableID.Bool
channel end_periodicEventHandlerState : SchedulableID
channel release_complete_PEH : SchedulableID.num
channel end_periodic_app : SchedulableID

 nametype ReleaseSync_PEH =  {|fire, end_releases |}
nametype  PTCSYnc =  {| get_periodicTerminating, set_periodicTerminating |}


 nametype PEHStateSync = {|get_controllingMission, set_controllingMission,
                          get_applicationTerminating, set_applicationTerminating,
                          get_missedReleases,set_missedReleases,
                          get_periodicTerminating, set_periodicTerminating,
                          get_startTime, set_startTime,
                          end_periodicEventHandlerState|}


nametype PEHFWChanSet = union(
  union(PEHStateSync, ManagedSchedulableFWChanSet),
  {|done_safeletFW, end_periodic_app,
get_missedReleases,set_missedReleases,
get_periodicTerminating,set_periodicTerminating,
end_periodicEventHandlerState,release_complete_PEH,
done_toplevel_sequencer, circwait, end_releases |}  )



PeriodicEventHandlerFW(schedulable, period, startTime, deadline, deadlineMissHandler) =
(
  PeriodicEventHandlerBehaviour(schedulable, startTime, period, deadline, deadlineMissHandler)
    [|PEHStateSync|]
  PeriodicEventHandlerState(schedulable, nullMissionId, False, period, startTime, deadline, deadlineMissHandler, 0, False)
)\PEHStateSync

PeriodicEventHandlerState(schedulable, controllingMission, applicationTerminating, period, startTime, deadline, deadlineMissHandler, missedReleases, periodicTerminating) =
(
  (
    get_controllingMission.schedulable!controllingMission ->
    PeriodicEventHandlerState(schedulable, controllingMission, applicationTerminating, period, startTime, deadline, deadlineMissHandler, missedReleases, periodicTerminating)
  )
  []
  (
    set_controllingMission.schedulable?newControllingMission ->
    PeriodicEventHandlerState(schedulable, newControllingMission, applicationTerminating, period, startTime, deadline, deadlineMissHandler, missedReleases, periodicTerminating)
   )
  []
  (
    get_applicationTerminating.schedulable!applicationTerminating ->
    PeriodicEventHandlerState(schedulable, controllingMission, applicationTerminating, period, startTime, deadline, deadlineMissHandler, missedReleases, periodicTerminating)
  )
  []
  (
    set_applicationTerminating.schedulable?newApplicationTerminating ->
    PeriodicEventHandlerState(schedulable, controllingMission, newApplicationTerminating, period, startTime, deadline, deadlineMissHandler, missedReleases, periodicTerminating)
  )
  []
  (
    get_missedReleases.schedulable!missedReleases ->
    PeriodicEventHandlerState(schedulable, controllingMission, applicationTerminating, period, startTime, deadline, deadlineMissHandler, missedReleases, periodicTerminating)
  )
  []
  (
    set_missedReleases.schedulable?newMissedReleases ->
     PeriodicEventHandlerState(schedulable, controllingMission, applicationTerminating, period, startTime, deadline, deadlineMissHandler, newMissedReleases, periodicTerminating)
  )
  []
  (
    get_periodicTerminating.schedulable!periodicTerminating ->
    PeriodicEventHandlerState(schedulable, controllingMission, applicationTerminating, period, startTime, deadline, deadlineMissHandler, missedReleases, periodicTerminating)
  )
  []
  (
    set_periodicTerminating.schedulable?newPeriodicTerminating ->
    PeriodicEventHandlerState(schedulable, controllingMission, applicationTerminating, period, startTime, deadline, deadlineMissHandler, missedReleases, newPeriodicTerminating)
  )
  []
  (
  get_startTime.schedulable!startTime ->
  PeriodicEventHandlerState(schedulable, controllingMission, applicationTerminating, period, startTime, deadline, deadlineMissHandler, missedReleases, periodicTerminating)

  )
[]
(
  set_startTime.schedulable?newStartTime ->
   PeriodicEventHandlerState(schedulable, controllingMission, applicationTerminating, period, newStartTime, deadline, deadlineMissHandler, missedReleases, periodicTerminating)

  )
  []
  (
    end_periodicEventHandlerState.schedulable ->
    SKIP
  )
)

PeriodicEventHandlerBehaviour(schedulable, startTime, period, deadline, deadlineMissHandler) =

(
    Start_PEH(schedulable) ;
    get_applicationTerminating.schedulable?applicationTerminating ->
    (
      if applicationTerminating == False then
      (
           Execute_PEH(schedulable, startTime, period, deadline, deadlineMissHandler)  ;
           Cleanup_PEH(schedulable) ;
           PeriodicEventHandlerBehaviour(schedulable, startTime, period, deadline, deadlineMissHandler)
      )
      else
         end_periodicEventHandlerState.schedulable ->
         end_periodic_app.schedulable ->
         SKIP
    )
)

Start_PEH(schedulable) =
 (
   Register_PEH(schedulable) --;
   --Activate_PEH(schedulable)
 )
 []
 (
  done_safeletFW ->
 set_applicationTerminating.schedulable!True ->
    SKIP
)
[]
 (
      activate_schedulables?someMissionID ->
      Start_PEH(schedulable)
 )
 []
 (
    done_toplevel_sequencer ->
    set_applicationTerminating.schedulable!True ->
    SKIP
   )

Register_PEH(schedulable) =
   register.schedulable?controllingMission ->
   Activate_PEH(schedulable, controllingMission)

Activate_PEH(schedulable, controllingMission) =
  --  get_controllingMission.schedulable?controllingMission ->
    activate_schedulables.controllingMission ->
    SKIP

Execute_PEH(schedulable, startTime, period, deadline, deadlineMissHandler) =
circwait.startTime ->
(
  (
    (
      if deadlineMissHandler != nullSchedulableId then
        RunningWithDeadlineDetection(schedulable, period, deadline, deadlineMissHandler)
      else
        Running(schedulable, period)
    )
    []
    (
      end_releases.schedulable ->
      signalTerminationRet.schedulable ->
      SKIP
    )
  )
    [|  {|end_releases, signalTerminationRet|} |]
  SignalTermination_PEH(schedulable)
)\{|end_releases|}


Running(schedulable, period)  =
(
  (fire.schedulable -> PeriodicClock(schedulable, period))
    [| ReleaseSync_PEH |]
  Release_PEH(schedulable,0)
)

RunningWithDeadlineDetection(schedulable, period, deadline, deadlineMissHandler) =
(
  Running(schedulable, period)
    [| {|release_complete, end_releases|} |]
  DeadlineClock_PEH(schedulable, 0, deadline, period, deadlineMissHandler)
)

PeriodicClock(schedulable, period) =
 (
  (
    circwait.period ->
    (
      (
        fire.schedulable ->
        PeriodicClock(schedulable, period)
      )
      []
      (
        end_releases.schedulable ->
       SKIP
      )
    )
  )
  []
  (
    end_releases.schedulable ->
    SKIP
  )
)


Release_PEH(schedulable, index) =
get_missedReleases.schedulable?missedReleases ->
(
  if missedReleases == 0 then
  (
    fire.schedulable ->
    releaseCall.schedulable ->
    SKIP
  )
  else
  (
    releaseCall.schedulable ->
    if missedReleases-1 < 0 then
      SKIP
    else
      set_missedReleases.schedulable!(missedReleases -1) ->
      SKIP
  )
);
(
  (
    releaseRet.schedulable ->
    release_complete_PEH.schedulable.index ->
    SKIP
  )
    [| {|releaseRet|} |]
  FireCatcher(schedulable)
) ;
(
  (
    get_periodicTerminating.schedulable?periodicTerminating:({False}) ->
    if index + 1 > maxNum then
      signalTerminationRet.schedulable ->
      SKIP
    else
      Release_PEH(schedulable, index + 1)
   )
  []
  (
    --get_periodicTerminating.schedulable?periodicTerminating:(periodicTerminating == True) ->
    end_releases.schedulable ->
    signalTerminationRet.schedulable ->
    SKIP
  )
)

FireCatcher(schedulable) =
(
  (
    fire.schedulable ->
    get_missedReleases.schedulable?missedReleases ->
    if missedReleases +1 > maxNum then
     SKIP
    else
      set_missedReleases.schedulable!(missedReleases +1) ->
      FireCatcher(schedulable)
  )
  []
  (
    releaseRet.schedulable ->
    SKIP
  )
)

DeadlineClock_PEH(schedulable, index, deadline, period, deadlineMissHandler) =
(
  (
  (
    (

        circwait.deadline ->
        fire.deadlineMissHandler ->
        release_complete_PEH.schedulable.index ->
        SKIP
      )
      []
      (
        release_complete_PEH.schedulable.index ->
        SKIP
      )
    )
    |||
    (
      (
        circwait.period ->
        if index +1 > maxNum then
          SKIP
        else
          DeadlineClock_PEH(schedulable, index + 1, deadline, period, deadlineMissHandler)
      )
    )
)
/\
  (
    end_releases.schedulableA ->
   -- release_complete_PEH.schedulable?index ->
    SKIP
  )
)

SignalTermination_PEH(schedulable) =
  signalTerminationCall.schedulable ->
  set_periodicTerminating.schedulable!True ->
  end_releases.schedulable ->
  signalTerminationRet.schedulable ->
  done_schedulable.schedulable ->
  SKIP

Cleanup_PEH(schedulable) =
  cleanupSchedulableCall.schedulable ->
  cleanupSchedulableRet.schedulable ->
  SKIP


assert PeriodicEventHandlerFW(schedulableA, 1, 0, 2, nullSchedulableId); Loop :[ deadlock free [FD] ]
assert PeriodicEventHandlerFW(schedulableA, 1, 0, 2, nullSchedulableId) :[ divergence free ]
assert PeriodicEventHandlerFW(schedulableA, 1, 0, 2, nullSchedulableId) :[ deterministic  [FD] ]

-- MANAGED THREAD

--MT Types



-- MT CHannels


channel runCall : SchedulableID
channel runRet : SchedulableID

channel end_managedThread_app : SchedulableID
channel end_managedThreadState : SchedulableID

nametype MTStateSync = {|get_controllingMission, set_controllingMission, get_applicationTerminating, set_applicationTerminating, end_managedThreadState |}
nametype ManagedThreadSync = {|runCall, runRet |}


nametype MTFWChanSet = union(
  union(MTStateSync, ManagedSchedulableFWChanSet),
  {|runCall,runRet, done_toplevel_sequencer |}   )

--Managed Thread

ManagedThreadFW(schedulable) =
(
  ManagedThreadFWState(schedulable, nullMissionId, False)
    [| MTStateSync |]
  ManagedThreadFWBehaviour(schedulable)
)\MTStateSync


ManagedThreadFWState(schedulable, controllingMission, applicationTerminating) =
  (
    get_controllingMission.schedulable!controllingMission ->
    ManagedThreadFWState(schedulable, controllingMission, applicationTerminating)
  )
  []
  (
    set_controllingMission.schedulable?newControllingMission ->
    ManagedThreadFWState(schedulable, newControllingMission, applicationTerminating)
  )
  []
  (
    get_applicationTerminating.schedulable!applicationTerminating ->
    ManagedThreadFWState(schedulable, controllingMission, applicationTerminating)
  )
  []
  (
    set_applicationTerminating.schedulable?newApplicationTerminating ->
    ManagedThreadFWState(schedulable, controllingMission, newApplicationTerminating)
  )
  []
  (
    end_managedThreadState.schedulable ->
    SKIP
  )


ManagedThreadFWBehaviour(schedulable) =

(
    Start_MT(schedulable) ;
  get_applicationTerminating.schedulable?applicationTerminating ->
  (
    if applicationTerminating == False then
      (
          Execute_MT(schedulable) ;
          Cleanup_MT(schedulable) ;
          ManagedThreadFWBehaviour(schedulable)
      )
      else
    (
      end_managedThreadState.schedulable ->
      end_managedThread_app.schedulable ->
      SKIP
    )
  )
)

Start_MT(schedulable) =
  (
   Register_MT(schedulable) --;
  -- Activate_MT(schedulable)
  )

  []
  (
  done_safeletFW ->
  set_applicationTerminating.schedulable!True ->
    SKIP
)
[]
  (
    activate_schedulables?someMissionID ->
    Start_MT(schedulable)
  )
  []
  (
    done_toplevel_sequencer ->
    set_applicationTerminating.schedulable!True ->
    SKIP
  )

Register_MT(schedulable) =
  register.schedulable?controllingMission ->
  Activate_MT(schedulable, controllingMission)


Activate_MT(schedulable, controllingMission) =
 -- get_controllingMission.schedulable?controllingMission ->
  activate_schedulables.controllingMission ->
  SKIP

Execute_MT(schedulable)  =
   Run_MT(schedulable)
      [| {| runRet |} |]
   Methods_MT(schedulable)


Run_MT(schedulable) =
  runCall.schedulable ->
  runRet.schedulable ->
  done_schedulable.schedulable ->
  SKIP


Methods_MT(schedulable) =
(
  SignalTerminationMeth_MT(schedulable) ;
  Methods_MT(schedulable)
)
[]
(
  runRet.schedulable ->
  SKIP
)

SignalTerminationMeth_MT(schedulable) =
  signalTerminationCall.schedulable ->
  signalTerminationRet.schedulable -> SKIP

Cleanup_MT(schedulable) =
  cleanupSchedulableCall.schedulable ->
  cleanupSchedulableRet.schedulable -> SKIP

assert ManagedThreadFW(schedulableA); Loop :[ deadlock free [FD] ]
assert ManagedThreadFW(schedulableA) :[ divergence free ]
assert ManagedThreadFW(schedulableA) :[ deterministic  [FD] ]

















channel nested_start_mission : MissionID.SchedulableID
channel nested_done_mission : MissionID.Bool



TopLevelMissionSequencers(toplevelSequencerIDs) =
([|{| done_safeletFW, done_toplevel_sequencer |}|] ms : toplevelSequencerIDs @ TopLevelMissionSequencerFW(ms))



Missions(missions) = ([|{| done_safeletFW, done_toplevel_sequencer |}|] m : missions @ MissionFW(m))

CatchBroadcasts =
  (done_safeletFW -> SKIP)
  []
  (done_toplevel_sequencer->SKIP)
  []
  (activate_schedulables?m -> CatchBroadcasts)

SchedulableSequencerFWs(schedulableSequencers) =
if schedulableSequencers != {} then
(
   [|{| activate_schedulables, done_safeletFW, done_toplevel_sequencer |}|] sms : schedulableSequencers @ SchedulableMissionSequencerFW(sms)
)
else
(
  CatchBroadcasts
)

AperiodicEventHandlerFWs(aperiodicEventHanders) =
if aperiodicEventHanders != {} then
(
   [|{| activate_schedulables, done_safeletFW, done_toplevel_sequencer |}|] (apeh, type, start, missHandler) : aperiodicEventHanders @ AperiodicEventHandlerFW(apeh, type, start, missHandler)
)
else
(
  CatchBroadcasts
)

OneShotEventHandlerFWs(oneShotEventHandlers)=
if oneShotEventHandlers != {} then
  (
   [|{| activate_schedulables, done_safeletFW, done_toplevel_sequencer |}|] (oseh, start, deadline, missHandler) : oneShotEventHandlers @ OneShotEventHandlerFW(oseh, start, deadline, missHandler )
)
else
(
  CatchBroadcasts
)

PeriodicEventHandlerFWs(periodicEventHandlers) =
if periodicEventHandlers != {} then
  (
   [|{| activate_schedulables, done_safeletFW, done_toplevel_sequencer |}|] (peh, period, start, deadline, missHandler) : periodicEventHandlers @ PeriodicEventHandlerFW(peh, period, start, deadline, missHandler)
)
else
(
  CatchBroadcasts
)

ManagedThreadFWs(managedThreads) =
if managedThreads != {} then
  (
   [|{| activate_schedulables, done_safeletFW, done_toplevel_sequencer |}|] mt : managedThreads @ ManagedThreadFW(mt)
)
else
(
  CatchBroadcasts
)

Schedulables(schedulableSequencers, aperiodicEventHanders, oneShotEventHandlers,periodicEventHandlers,managedThreads)=
(
  (
    (
      (
        (
          SchedulableSequencerFWs(schedulableSequencers)
              [|{| activate_schedulables, done_safeletFW, done_toplevel_sequencer |}|]
          AperiodicEventHandlerFWs(aperiodicEventHanders)
        )
            [|{|  activate_schedulables, done_safeletFW, done_toplevel_sequencer |}|]
        OneShotEventHandlerFWs(oneShotEventHandlers)
      )
          [|{| activate_schedulables,done_safeletFW, done_toplevel_sequencer |}|]
      PeriodicEventHandlerFWs(periodicEventHandlers)
      )
          [|{| activate_schedulables,done_safeletFW, done_toplevel_sequencer |}|]
      ManagedThreadFWs(managedThreads)
    )
)



nametype SafeltSync = {| done_safeletFW, start_toplevel_sequencer, done_toplevel_sequencer, register, deregister, checkSchedulable|}

nametype TopLevelMissionSequencerSync = {|done_safeletFW, start_mission, done_mission, done_toplevel_sequencer|}

nametype MissionSync = {| done_safeletFW, done_toplevel_sequencer,
                   signalTerminationCall, signalTerminationRet, activate_schedulables, done_schedulable,
                   cleanupSchedulableCall, cleanupSchedulableRet, register |}





nametype SafeletTierSync = {|start_toplevel_sequencer, done_toplevel_sequencer, done_safeletFW |}
nametype SafeletTierChan = union(SafeletFWChanSet, TopLevelMissionSequencerFWChanSet)


SafeletTier(topLevelMissionSequencerIDs) =
(
  SafeletFW
  [|SafeletTierSync|]
  TopLevelMissionSequencers(topLevelMissionSequencerIDs)
)



nametype TierChanSet = Union({ MissionFWCHanSet, SchedulableMissionSequencerFWChanSet, MTFWChanSet, APEHFWChanSet, PEHFWChanSet, OSEHFWChanSet, {|register|} })

Tier(missionIDs,  (schedulableSequencers, aperiodicEventHanders, oneShotEventHandlers,periodicEventHandlers,managedThreads) ) =
 (
    Missions(missionIDs)
    [|MissionSync|]
    Schedulables(schedulableSequencers, aperiodicEventHanders, oneShotEventHandlers,periodicEventHandlers,managedThreads)
)
-- ({FirstMissionSequencerID},{(schedulableA, aperiodic, 2, nullSchedulableId)}, {},  {}, {schedulableB})
Tier0(missionIDs, managedSchedulableIDs  )=
(
Tier(missionIDs, managedSchedulableIDs )
--[| RouterSync |]
--Router(missionIDs)
)
--(apeh, type, start, missHandler) : aperiodicEventHanders




nametype TierCommonChan = {|done_toplevel_sequencer, done_safeletFW|}
nametype TierSpecificChan = {|start_mission, done_mission, initializeRet, requestTermination |}

--datatype TierInterface = TierSpecificChan.MissionID

nametype MissionAndSchedulableChans = Union({MissionFWCHanSet, SchedulableMissionSequencerFWChanSet, MTFWChanSet, APEHFWChanSet, PEHFWChanSet, OSEHFWChanSet})

nametype SchedulableEndApps =  {| end_managedThread_app, end_sequencer_app, end_periodic_app, end_aperiodicEventHandler_app,
                                  end_oneshotEventHandler_app  |}

NestedTiers(nestedTierIDs) =
(
  || (missionIDs, managedSchedulableIDs) : nestedTierIDs @
      [ Union({ SchedulableEndApps,
        diff(MissionAndSchedulableChans, {|start_mission, done_mission, initializeRet, requestTermination|} ),
        {| start_mission.x, done_mission.x, initializeRet.x, requestTermination.x, register.s.x | s <-SchedulableID, x <- MissionID , member(x, missionIDs) |} })
      ]
        Tier(missionIDs, managedSchedulableIDs)
)



nametype TierSync = {|start_mission.missionA, done_mission.missionA, register, deregister, checkSchedulable, done_safeletFW, done_toplevel_sequencer|}

nametype NestedTeirSync = {|start_mission, done_mission, initializeRet, nested_start_mission, nested_done_mission |}




nametype Tier0Chan = union(diff(TierChanSet, {|start_mission, done_mission|}), {|start_mission.missionA.TopLevelSequencerId, done_mission.missionA.True, done_mission.missionA.False |})




nametype NestedTeirChan = union(diff(TierChanSet, {|start_mission, done_mission|}), {|start_mission.missionB.FirstMissionSequencerID, done_mission.missionA.True, done_mission.missionA.False |})


--makeTierInterface(MIds) = TierSpecificChan.MIds

p(nestedTierIDs) = {m | (missionIDs, managedSchedulableIDs) <-nestedTierIDs, m <- MissionID, member(m, missionIDs ) }


TieredFramework(topLevelSequencerIDs, tier0MissionIDs, tier0SchedulableIDS, nestedTierIDs) =
(
  SafeletTier(topLevelSequencerIDs)
    [|TierSync|]
  (
    Tier0(tier0MissionIDs,tier0SchedulableIDS)
      [| union(
                  TierCommonChan,
                  {| start_mission.x, done_mission.x, initializeRet.x, requestTermination.x  | x <- MissionID , member(x, p(nestedTierIDs) ) |}
               )
      |]
    NestedTiers( nestedTierIDs )
  )
)
--{| start_mission.missionB, done_mission.missionB, initializeRet.missionB, done_toplevel_sequencer, done_safeletFW, requestTermination.missionB  |}

--Tier0Chan || NestedTeirChan
                  --{}, {(schedulableA, aperiodic, 2, nullSchedulableId)}, {},  {}, {schedulableB}
SimpleTieredFramework =
  TieredFramework({TopLevelSequencerId},
                  {missionA},
                  ({FirstMissionSequencerID},{(schedulableA, aperiodic, 2, nullSchedulableId)}, {},  {}, {schedulableB}),
                  {({missionB}, ({}, {}, {},  {}, {schedulableC}))}
                  )


JustNestedTier =
  NestedTiers({({missionB}, ({FirstMissionSequencerID}, {(schedulableA, aperiodic, 2, nullSchedulableId)}, {},  {}, {schedulableC}))})

JustTier =
  Tier({missionA}, ({FirstMissionSequencerID},{(schedulableA, aperiodic, 2, nullSchedulableId)}, {},  {}, {schedulableB}))

assert sbisim(diamond(JustNestedTier)) [T= STOP

JustTiers =
 Tier0({missionA},({FirstMissionSequencerID},{(schedulableA, aperiodic, 2, nullSchedulableId)}, {},  {}, {schedulableB}))
      [| union(
                  TierCommonChan,
                  {| start_mission.x, done_mission.x, initializeRet.x, requestTermination.x  | x <- MissionID , member(x, p({({missionB}, ({}, {}, {},  {}, {schedulableC}))}) ) |}
               )
      |]
 NestedTiers({({missionB}, ({}, {}, {},  {}, {schedulableC}))})

assert sbisim(diamond(SimpleTieredFramework)) ; Loop :[ deadlock free [FD] ]
assert sbisim(diamond(SimpleTieredFramework)) :[ divergence free ]
assert sbisim(diamond(SimpleTieredFramework)) :[ deterministic  [FD] ]
